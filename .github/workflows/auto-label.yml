name: Auto-label pull requests

on:
  pull_request:
    types: [opened, edited, reopened, synchronize]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  autolabel:
    if: ${{ github.event.pull_request.head.repo.fork == false }}
    runs-on: ubuntu-latest
    steps:
      - name: Add labels based on title and files
        uses: actions/github-script@v8
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              console.log('No pull request in context');
              return;
            }

            const number = pr.number;
            const title = pr.title || '';
            const body = pr.body || '';
            const existing = (pr.labels || []).map(l => l.name);

            // Skip if maintainer added a skip label
            if (existing.includes('skip-autolabel') || existing.includes('skip-changelog')) {
              console.log('Skipping autolabel due to skip label');
              return;
            }

            const rules = [
              { name: 'feature', regex: /\b(feat|feature|enhancement|\[feat\]|\[feature\]|^feat:|resolves)/i },
              { name: 'fix', regex: /\b(fix|bug|bugfix|\[fix\]|^fix:)/i },
              { name: 'docs', regex: /\b(doc|docs|documentation|\[docs\]|^docs:)/i },
              { name: 'chore', regex: /\b(chore|ci|build|refactor|deps|dependency|\[chore\]|^chore:)/i },
              { name: 'security', regex: /\b(security|cve|\[security\]|^security:)/i }
            ];

            const found = new Set();

            // Auto-skip changelog for Dependabot PRs
            const author = (pr.user && pr.user.login) || '';
            if (/^dependabot/i.test(author)) {
              found.add('skip-changelog');
            }

            // track parser-derived labels separately so we can give precedence to mapped labels
            const ruleFound = new Set();
            for (const r of rules) {
              if (r.regex.test(title) || r.regex.test(body)) ruleFound.add(r.name);
            }

            // Also check for linked issues and copy/ map their labels to PR labels
            //  - parses "fixes #NN" style references from title/body
            //  - checks the issue/PR timeline for cross-references
            //  - maps issue labels to PR labels based on `labelMap`
            try {
              const refRegex = /(?:close[sd]?|fixe?s?|resolve[sd]?|resolves|closes|refs?)\s+#(\d+)/ig;
              const text = (title + '\n' + body);
              const referenced = new Set();
              let m;
              while (m = refRegex.exec(text)) referenced.add(Number(m[1]));

              // also check timeline for cross-referenced issues (more robust)
              const timeline = await github.paginate(github.rest.issues.listEventsForTimeline, {
                owner: context.repo.owner, repo: context.repo.repo, issue_number: number
              });
              for (const ev of timeline) {
                if (ev.event === 'cross-referenced' && ev.source && ev.source.issue && ev.source.issue.number) {
                  referenced.add(ev.source.issue.number);
                }
              }

              const labelMap = {
                'bug': 'fix',
                'enhancement': 'feature',
                'maintainability': 'chore',
                'skip-changelog': 'skip-changelog'
              };

              // collect mapped labels separately so we can prefer them over parser matches
              const mappedLabels = new Set();

              for (const issueNum of referenced) {
                try {
                  const { data: labels } = await github.rest.issues.listLabelsOnIssue({
                    owner: context.repo.owner, repo: context.repo.repo, issue_number: issueNum
                  });
                  for (const l of labels) {
                    const mapped = labelMap[l.name];
                    if (mapped) {
                      mappedLabels.add(mapped);
                      found.add(mapped);
                    }
                  }
                } catch (e) {
                  console.log(`Unable to get labels for issue #${issueNum}: ${e.message}`);
                }
              }

              // If any mapped labels exist, prefer them and skip parser-derived type labels (fix/feature/etc.).
              // Parser is still used to detect platform labels like `tauri` and `frontend`.
              if (mappedLabels.size === 0) {
                for (const rf of ruleFound) found.add(rf);
              } else {
                console.log('Mapped labels found, skipping parser-derived type labels:', Array.from(mappedLabels).join(', '));
              }
            } catch (e) {
              console.log('Error while resolving linked issues:', e.message);
            }

            // detect platform-specific files
            const files = await github.paginate(github.rest.pulls.listFiles, { owner: context.repo.owner, repo: context.repo.repo, pull_number: number });
            const paths = files.map(f => f.filename);
            if (paths.some(p => p.includes('src-tauri') || p.includes('app/src-tauri'))) found.add('tauri');
            if (paths.some(p => p.startsWith('app/src') || p.includes('src/'))) found.add('frontend');

            // Remove labels that are already present
            const labelsToAdd = Array.from(found).filter(l => !existing.includes(l));
            if (labelsToAdd.length === 0) {
              console.log('No new labels to add');
              return;
            }

            // Ensure labels exist (create if missing)
            for (const label of labelsToAdd) {
              try {
                await github.rest.issues.getLabel({ owner: context.repo.owner, repo: context.repo.repo, name: label });
              } catch (e) {
                // create default label with neutral color
                await github.rest.issues.createLabel({ owner: context.repo.owner, repo: context.repo.repo, name: label, color: 'cccccc', description: 'Automatically created label' }).catch(err => console.log('Unable to create label', label, err.message));
              }
            }

            await github.rest.issues.addLabels({ owner: context.repo.owner, repo: context.repo.repo, issue_number: number, labels: labelsToAdd });
            console.log('Added labels to PR #' + number + ': ' + labelsToAdd.join(', '));
